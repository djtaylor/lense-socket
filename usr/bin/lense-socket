/**
 * Lense Socket.IO Server
 * 
 * A Node.JS/Socket.IO API proxy server to handle requests from the Lense web UI.
 * Loads configuration options from the /etc/lense/socket.conf file.
 */
function SocketProxy() {
	self 	     = this;
	
	// String truncating
	String.prototype.trunc = String.prototype.trunc ||
	function(n){
    	return this.length>n ? this.substr(0,n-1)+'...' : this;
	};
	
	// Socket.IO connection
	this.sock    = false;
	
	// Configuration and logger object
	this.conf    = false;
	this.log     = false;
	
	// API URL
	this.api_url = null;
	
	// Module path
	this.modules = '/usr/share/lense/socket/node_modules'
	
	// Filesystem and Socket.IO modules
	this.fs      = require('fs');
	this.io      = require(self.modules + '/socket.io');
	
	// Listener and request HTTP modules
	this.http_l  = require('http');
	this.http_r  = require('http');
	
	// Listener and request HTTPS modules
	this.https_l = require('https');
	this.https_r = require('https');
	
	// Logger module
	this.winston = require(self.modules + '/winston');
	
	/**
	 * Socket Configuration
	 * 
	 * Method used to parse the /etc/lense/engine.conf file.
	 */
	this.conf_init = function() {
		conf_file = self.fs.readFileSync('/etc/lense/socket.conf', 'utf-8')
		
		// Attempt the parse the configuration
		try {
			
			// Parse the configuration object
			self.conf = JSON.parse(conf_file);
		} catch (e) {
			console.log('Failed to parse configuration file \'' + conf_file + '\': ' + e);
			process.exit(1);
		}
		
		// Validate the configuration
		try {
			if (self.conf.hasOwnProperty('socket')) { 
				socket_required = ['host', 'proto', 'port'];
				for (var key in socket_required) {
					if (! self.conf.socket.hasOwnProperty(socket_required[key])) {
						console.log('Missing required key \'' + socket_required[key] + '\' in socket config group');
						process.exit(1);
					}
				}
			} else {
				console.log('Missing required \'socket\' group in config file: ' + conf_file); 
				process.exit(1);
			}
		} catch (e) {
			console.log('Failed to validate the configuration file \'' + conf_file + '\': ' + e);
			process.exit(1);
		}
	}
	
	/**
	 * Socket Logger
	 * 
	 * Method used to set up the Socket logger object.
	 */
	this.log_init = function() {
		try {
			self.log = new (self.winston.Logger)({
				level: 'debug',
				transports: [
				    new (self.winston.transports.File)({
				    	filename:  self.conf.socket.log,
			    		colorize:  false,
			    		timestamp: true,
			    		maxsize:   5242880,
			    		json:      false
				    })
				]
			});
			
			// Initial log messages
			self.log.info('Initialized Socket.IO proxy logger');
			self.log.info('Parsed Socket.IO proxy configuration file: ');
			
			// Log the configuration parsed at runtime
			for (var group_key in self.conf) {
				for (var conf_key in self.conf[group_key]) {
					self.log.info('CONFIG: ' + group_key + '.' + conf_key + ' = ' + self.conf[group_key][conf_key]);
				}
			}
		} catch (e) {
			console.log('Failed to initialize logger: ' + e);
			process.exit(1);
		}
	}
	
	/**
	 * Socket Initialize
	 * 
	 * Open up the Socket.IO port and start the process.
	 */
	this.socket_init = function() {
    	self.log.info('Initializing Socket.IO listener');
		
    	// Set up the listener
    	try {
    		
    		// HTTP
        	if (self.conf.socket.proto == 'http') {
        		self.http_l = self.http_l.createServer();
        		self.http_l.listen(self.conf.socket.port, self.conf.socket.bind_ip);
        		self.sock = self.io.listen(self.http_l);
        	}
        	
        	// HTTPS
        	if (self.conf.socket.proto == 'https') {
            	var ssl_options = {
            		key:    self.fs.readFileSync(self.conf.socket.ssl_key),
            	    cert:   self.fs.readFileSync(self.conf.socket.ssl_cert),
            	    ca:		self.fs.readFileSync(self.conf.socket.ssl_ca)	
            	}
            	self.https_l = self.https_l.createServer(options);
            	self.https_l.listen(self.conf.socket.port, self.conf.socket.host);
            	self.sock  = self.io.listen(self.https_l);
        	}
        	
        	// Listener is running
        	self.log.info('Started Socket.IO listener');
        	
        // Error in Socket.IO
    	} catch (e) {
    		console.log(e);
    		self.log.error('Failed to set up Socket.IO listener: ' + e);
    		process.exit(1);
    	}
	}
	
	/**
	 * Validate Proxy API Request
	 */
	this.valid_request = function(obj) {
		
		// Required base and socket parameters
		br = ['api_user', 'api_token', 'api_group', 'socket', 'action'];
		sr = ['method', 'path', 'room'];
		
		// Validate the required base parameters
		for (var k in br) {
			if (! obj.hasOwnProperty(br[k])) {
				self.log.error('Missing required base key \'' + br[k] + '\' in request body');
				return false;
			}
		}
		
		// Validate the required socket parameters
		for (var k in sr) {
			if (! obj.socket.hasOwnProperty(sr[k])) {
				self.log.error('Missing required socket key \'' + sr[k] + '\' in request body');
				return false;
			}
		}
		
		// Request looks OK
		return true;
	}
	
	/**
	 * Web Socket Response Logger
	 * 
	 * Helper method to log a proxied response back to the web user and session.
	 */
	this.wrlog = function(cl,cd,ct) {
		self.log.info('WebSocket_Response: room=' + cl.socket.room + ', code=' + cd + ', content=' + ct.trunc(75));
	}
	
	/**
	 * API Response Logger
	 * 
	 * Helper method to parse the response object and response data from an API request and
	 * generate the relevant log entries.
	 */
	this.arlog = function(r,c) {
		self.log.info('HTTP_Response ' + r.statusCode + ': ' + c.trunc(75));
	}
	
	/**
	 * Client Request Logger
	 * 
	 * Helper method to parse a client request object and generate the relevant log entries.
	 */
	this.crlog = function(c) {
		self.log.info('HTTP_Request[\'' + c.socket.method + '\']: ' + self.api_url + '/' + c.socket.path + '/' + c.action + (function() {
			if (c.hasOwnProperty('_data')) {
				return ', _data=' + JSON.stringify(c._data);
			}
			return '';
		})());
	}
	
	/**
	 * Submit API Request
	 * 
	 * Submit an API request to the main API server with the request method, room for the
	 * web socket, API endpoint (path and action), and the request data.
	 */
	this.api_submit = function(client) {
		self.crlog(client);
    	
    	// Options for the request
    	var request_options = {
    		host:   self.conf.engine.host,
    	    port:   self.conf.engine.port,
    	    path:   '/' + client.socket.path,
    	    method: client.socket.method.toUpperCase(),
    	    headers: {
    	    	'Content-Type': 'application/json',
    	        'Content-Length': request_data.length,
    	        'CS-API-User': client.auth.user,
    	        'CS-API-Group': client.auth.group,
    	        'CS-API-Token': client.auth.token
    	    }
    	};
    	
    	// HTTP request callback handler
    	var callback = function(response) {
    		response.setEncoding('utf8');
    		
    		// Response content and status code containers
    		var content = '';
    		var code;
    		
    		/**
    		 * Submit API Request
    		 * 
    		 * Forward a proxied API request from the web UI to the API server.
    		 */
    		response.on('data', function(chunk) {
    			self.arlog(response, chunk);
    			
    			// Store the response content and status code
    			content += chunk;
    			code     = response.statusCode 
    		});
    		
    		/**
    		 * Return API Response
    		 * 
    		 * Forward the response for a proxied API request from the API server
    		 * back to the web UI.
    		 */
    		response.on('end', function() {
    			self.wrlog(client, code, content);
    			
    			// Get the response type and emit to the appropriate web socket room
    			type = code == 200 ? 'info' : 'error';
    			self.sock.sockets.in(client.socket.room).emit('response', { type: type, code: code, content: content });
    		});
    	}
    	
    	// Submit the HTTP request
    	var request = self.http_r.request(request_options, callback);
    	
    	// If any request data found for a POST request
    	if (client.socket.method == 'post' && client.hasOwnProperty('_data')) {
    		request.write(client._data);
    	}
        
        // Catch any connection errors
        request.on('error', function(e) {
        	self.log.error(e.message);
        });
        
        // End the connection and destroy
        request.end();
	}
	
	/**
	 * Socket Run
	 * 
	 * Parent method used to bootstrap the Socket.IO API proxy server. Sets up the
	 * configuration, logger, validates parameters, then opens the socket connection.
	 */
	this.run = function() {
		
		// Load configuration
		self.conf_init();
		
		// Define the API url
		self.api_url = self.conf.engine.proto + '://' + self.conf.engine.host + ':' + self.conf.engine.port;
		
		// Set up the logger
		self.log_init();
		
		// Open the socket
		self.socket_init();
		
		// Handle client connections
		self.sock.sockets.on('connection', function(socket) {  
	    	
	    	// Join the client to the appropriate room
	    	socket.on('join', function(data) {
	    		self.log.info('Joined socket connection <' + socket.id + '> to room <' + data.room + '>');
	    		socket.join(data.room);
	    	});
	    
	    	// Handle sending updates from the API to the web client
	    	socket.on('update', function(data) {
	    		
	    		// If sending to a specific room
	    		if (data.hasOwnProperty('room')) {
	    			self.sock.sockets.in(data.room).emit(
    	    			'update', { type: data.type, content: data.content }
    	    		);
	    			
	    		// If sending to all clients
	    		} else {
	    			self.sock.sockets.emit(
    	    			'update', { type: data.type, content: data.content }
    	    		);
	    		}  		
	    	});
	    	
	    	// Handle errors
	    	socket.on('error', function(e) {
	    		self.log.error(e.message);
	    	});
	    	
	    	// Handle API requests
	    	socket.on('submit', function(client) {
	    		
	    		// Validate the request object
	    		if (self.valid_request(client) === false) {
	    			self.log.error('Invalid request object');
	    		} else {
	    			
	    			// Set the log metadata
	    			log_meta = {
	    				'socket_id': socket.id,
	    				'request':   client
	    			}
	    			
	    			// Handle the request
	    			self.log.info('Processing client request: ', log_meta);
	    			
	    			// Submit the API request
	    			self.api_submit(client);
	    		}
	    	});
	    });
	}
}

// Initialize CloudScape SocketIO server
var p = new SocketProxy().run();